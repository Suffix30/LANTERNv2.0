import re
import asyncio
from typing import Dict, List, Optional, Set
from urllib.parse import urljoin
from modules.base import BaseModule


class WafModule(BaseModule):
    name = "waf"
    description = "WAF Detection & Fingerprinting"
    
    waf_signatures = {
        "cloudflare": {
            "headers": ["cf-ray", "cf-cache-status", "cf-request-id"],
            "cookies": ["__cfduid", "__cf_bm", "cf_clearance"],
            "body": ["cloudflare", "attention required", "cf-error-details", "ray id"],
            "server": ["cloudflare"],
        },
        "akamai": {
            "headers": ["x-akamai-transformed", "akamai-origin-hop", "x-akamai-request-id"],
            "cookies": ["akamai", "ak_bmsc", "bm_sv", "bm_sz"],
            "body": ["akamai", "access denied", "reference #"],
            "server": ["akamaighost", "akamai"],
        },
        "aws_waf": {
            "headers": ["x-amzn-requestid", "x-amz-cf-id", "x-amz-id-2"],
            "cookies": ["awsalb", "awsalbcors", "aws-waf-token"],
            "body": ["aws", "request blocked", "automated access"],
            "server": ["awselb", "amazons3"],
        },
        "aws_cloudfront": {
            "headers": ["x-amz-cf-pop", "x-amz-cf-id"],
            "cookies": [],
            "body": ["cloudfront", "generated by cloudfront"],
            "server": ["cloudfront"],
        },
        "imperva": {
            "headers": ["x-iinfo", "x-cdn"],
            "cookies": ["incap_ses", "visid_incap", "nlbi_"],
            "body": ["incapsula", "imperva", "incident id", "_incapsula_resource"],
            "server": ["imperva"],
        },
        "sucuri": {
            "headers": ["x-sucuri-id", "x-sucuri-cache"],
            "cookies": ["sucuri_cloudproxy"],
            "body": ["sucuri", "cloudproxy", "access denied - sucuri"],
            "server": ["sucuri"],
        },
        "f5_bigip": {
            "headers": ["x-wa-info", "x-cnection"],
            "cookies": ["bigipserver", "ts", "f5_cspm"],
            "body": ["f5 networks", "bigip", "request rejected"],
            "server": ["bigip", "f5"],
        },
        "barracuda": {
            "headers": ["barra_counter_session"],
            "cookies": ["barra_counter_session", "bni_"],
            "body": ["barracuda", "barra_counter_session"],
            "server": ["barracuda"],
        },
        "modsecurity": {
            "headers": ["x-mod-security", "mod_security"],
            "cookies": [],
            "body": ["mod_security", "modsecurity", "not acceptable", "security rules"],
            "server": ["mod_security"],
        },
        "fortinet": {
            "headers": [],
            "cookies": ["fortiwafsid", "cookiesession1"],
            "body": ["fortiweb", "fortigate", ".fgd_icon"],
            "server": ["fortiweb"],
        },
        "citrix": {
            "headers": ["cneonction", "nncoection", "x-citrix-request-id"],
            "cookies": ["citrix_ns_id", "nsc_"],
            "body": ["citrix", "netscaler", "ns_af"],
            "server": ["netscaler"],
        },
        "radware": {
            "headers": ["x-sl-compstate"],
            "cookies": [],
            "body": ["radware", "appwall", "unauthorized activity"],
            "server": ["radware"],
        },
        "palo_alto": {
            "headers": [],
            "cookies": [],
            "body": ["palo alto", "threat prevention", "url filtering"],
            "server": [],
        },
        "wordfence": {
            "headers": [],
            "cookies": ["wfwaf-authcookie"],
            "body": ["wordfence", "generated by wordfence", "blocked by wordfence"],
            "server": [],
        },
        "nginx_naxsi": {
            "headers": ["x-naxsi-sig"],
            "cookies": [],
            "body": ["naxsi", "blocked request"],
            "server": [],
        },
        "comodo": {
            "headers": [],
            "cookies": [],
            "body": ["comodo waf", "protected by comodo"],
            "server": ["comodo"],
        },
        "stackpath": {
            "headers": ["x-sp-waf-id", "x-sp-cdn"],
            "cookies": [],
            "body": ["stackpath", "highwinds"],
            "server": ["stackpath"],
        },
        "reblaze": {
            "headers": ["x-rb-session"],
            "cookies": ["rbzid", "rb_"],
            "body": ["reblaze", "access denied"],
            "server": ["reblaze"],
        },
        "fastly": {
            "headers": ["x-served-by", "x-cache", "fastly-restarts"],
            "cookies": [],
            "body": ["fastly error"],
            "server": ["fastly"],
        },
        "edgecast": {
            "headers": ["x-ec-custom-error"],
            "cookies": [],
            "body": ["edgecast"],
            "server": ["ecs", "ecd"],
        },
        "azure_frontdoor": {
            "headers": ["x-azure-ref", "x-fd-healthprobe"],
            "cookies": [],
            "body": ["azure front door"],
            "server": [],
        },
        "google_cloud": {
            "headers": ["x-cloud-trace-context", "x-goog-"],
            "cookies": [],
            "body": ["google cloud", "error 403"],
            "server": ["gws", "gse"],
        },
    }
    
    trigger_payloads = [
        "<script>alert(1)</script>",
        "' OR '1'='1",
        "../../../etc/passwd",
        "; cat /etc/passwd",
        "{{7*7}}",
        "${7*7}",
        "<img src=x onerror=alert(1)>",
        "UNION SELECT * FROM",
        "<?php system($_GET['cmd']); ?>",
    ]
    
    async def scan(self, target):
        self.findings = []
        self.detected_wafs: Set[str] = set()
        self.waf_version: Optional[str] = None
        
        base_url = urljoin(target, "/")
        
        tasks = [
            self._passive_detection(base_url),
            self._active_detection(base_url),
            self._block_page_analysis(base_url),
        ]
        await asyncio.gather(*tasks)
        
        if self.detected_wafs:
            self.add_finding(
                "INFO",
                f"WAF Detected: {', '.join(self.detected_wafs)}",
                url=target,
                evidence=f"Detected {len(self.detected_wafs)} WAF(s)"
            )
        
        return self.findings
    
    async def _passive_detection(self, target):
        resp = await self.http.get(target)
        if not resp.get("status"):
            return
        
        headers = {k.lower(): v.lower() for k, v in resp.get("headers", {}).items()}
        cookies = resp.get("cookies", {})
        body = resp.get("text", "").lower()
        server = headers.get("server", "").lower()
        
        for waf_name, signatures in self.waf_signatures.items():
            if self._check_signatures(waf_name, signatures, headers, cookies, body, server):
                self.detected_wafs.add(waf_name)
    
    async def _active_detection(self, target):
        for payload in self.trigger_payloads[:5]:
            test_url = f"{target}?test={payload}"
            
            try:
                resp = await self.http.get(test_url)
            except:
                continue
            
            if not resp.get("status"):
                continue
            
            status = resp.get("status")
            headers = {k.lower(): v.lower() for k, v in resp.get("headers", {}).items()}
            cookies = resp.get("cookies", {})
            body = resp.get("text", "").lower()
            server = headers.get("server", "").lower()
            
            if status in [403, 406, 429, 503]:
                for waf_name, signatures in self.waf_signatures.items():
                    if self._check_signatures(waf_name, signatures, headers, cookies, body, server):
                        self.detected_wafs.add(waf_name)
                        break
    
    async def _block_page_analysis(self, target):
        malicious_url = f"{target}/<script>alert(1)</script>?id=' OR '1'='1"
        
        try:
            resp = await self.http.get(malicious_url)
        except:
            return
        
        if not resp.get("status"):
            return
        
        body = resp.get("text", "").lower()
        
        block_indicators = [
            ("access denied", None),
            ("request blocked", None),
            ("forbidden", None),
            ("not acceptable", None),
            ("security violation", None),
            ("attack detected", None),
            ("malicious request", None),
            ("suspicious activity", None),
            ("blocked by", None),
            ("ray id:", "cloudflare"),
            ("incident id:", "imperva"),
            ("reference #", "akamai"),
            ("powered by", None),
        ]
        
        for indicator, waf_hint in block_indicators:
            if indicator in body:
                if waf_hint:
                    self.detected_wafs.add(waf_hint)
                
                if not self.detected_wafs:
                    self.add_finding(
                        "INFO",
                        "WAF/Security Filter Detected (Unknown Vendor)",
                        url=target,
                        evidence=f"Block indicator: {indicator}"
                    )
                break
    
    def _check_signatures(self, waf_name, signatures, headers, cookies, body, server):
        for header in signatures.get("headers", []):
            if header.lower() in headers:
                version_match = re.search(r'[\d.]+', headers.get(header.lower(), ''))
                if version_match:
                    self.waf_version = version_match.group(0)
                return True
        
        for cookie in signatures.get("cookies", []):
            if any(cookie.lower() in c.lower() for c in cookies):
                return True
        
        for pattern in signatures.get("body", []):
            if re.search(re.escape(pattern.lower()), body, re.IGNORECASE):
                return True
        
        for srv in signatures.get("server", []):
            if re.search(re.escape(srv.lower()), server, re.IGNORECASE):
                return True
        
        return False
    
    def get_detected_wafs(self) -> List[str]:
        return list(self.detected_wafs)
    
    def get_bypass_recommendations(self) -> Dict[str, List[str]]:
        recommendations = {}
        
        bypass_techniques = {
            "cloudflare": [
                "Unicode normalization bypass",
                "Chunked transfer encoding",
                "HPP (HTTP Parameter Pollution)",
                "Case variation (sElEcT)",
                "Double URL encoding",
                "Null byte injection (%00)",
            ],
            "akamai": [
                "Request header pollution",
                "Content-Type manipulation",
                "Multipart form data encoding",
                "URL path normalization",
                "HPP variations",
            ],
            "aws_waf": [
                "JSON body encoding",
                "Multipart boundary confusion",
                "Content-Length manipulation",
                "HTTP method override",
            ],
            "imperva": [
                "Unicode encoding",
                "Comment injection (/**/)",
                "Hex encoding",
                "Overlong UTF-8",
            ],
            "modsecurity": [
                "Paranoia level-aware payloads",
                "Rule ID specific bypasses",
                "Chainability exploitation",
                "Transformation bypass",
            ],
            "f5_bigip": [
                "ASM policy bypass",
                "Parameter pollution",
                "Encoding chains",
            ],
            "default": [
                "Double URL encoding",
                "Unicode encoding",
                "Case mixing",
                "Comment injection",
                "Null bytes",
                "Parameter pollution",
            ],
        }
        
        for waf in self.detected_wafs:
            if waf in bypass_techniques:
                recommendations[waf] = bypass_techniques[waf]
            else:
                recommendations[waf] = bypass_techniques["default"]
        
        return recommendations
